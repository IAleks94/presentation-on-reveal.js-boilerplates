# Презентация React

### Слайд 1 "Введение"

React  — это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный UI из маленьких изолированных кусочков кода, называемых «компонентами».

*Особенности*

+ Декларативный:

> Вам достаточно описать, как части интерфейса приложения выглядят в разных состояниях. React будет своевременно их обновлять, когда данные изменяются.

> Декларативные представления сделают код более предсказуемым и упростят отладку.

+ Основан на компонентах:

> Инкапсулированные компоненты имеют собственным состоянием, а затем объединяются в сложные пользовательские интерфейсы.

> Поскольку логика компонента написана на JavaScript, а не содержится в шаблонах, можно с лёгкостью передавать самые разные данные по всему приложению и держать состояние вне DOM.

> Для небольших проектов от этого не так много проку, так как компоненты зачастую являются уникальными. Но на крупном проекте позволит многократно использовать однажды созданные компоненты.

***

### Слайд 2 React обновляет только то, что необходимо

React обновляет только то, что необходимо
React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.

***

### Слайд 3 "Компонент и props"

React-компоненты реализуют метод render(), который принимает входные данные и возвращает что-то для вывода. Обычно используется XML-подобный синтаксис под названием JSX. Что позволяет разработчику легче представить конечный результат. Входные данные, передаваемые в компонент, доступны через this.props.

### Подслайд 1 к слайду 3 JSX

JSX производит «элементы» React.

React исходит из принципа, что логика рендеринга неразрывно связана с прочей логикой UI: с тем, как обрабатываются события, как состояние изменяется во времени и как данные готовятся к отображению.

Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику в разные файлы (обычно у нас есть файл html содержащий разметку, файл JS содержащий логику и файл css содержащий стили), React разделяет ответственность с помощью слабо связанных единиц, называемых «компоненты», которые содержат и разметку, и логику (то есть по сути мы пишем HTML внутри JS файла).

### Подслайд 2 к слайду 3 styled components (самую капельку)

Мы можем пойти дальше и воспользоваться styled components что позволит добавить в компонент еще и стили, но это отдельная, обширная тема. Если вы используя React, вывели на экран хотя бы "Hello World!", советую ознакомиться и со styled components.

### Подслайд 3 к слайду 3 Встраивание выражений в JSX

Если вы использовали innerHtml для создания элементов через JS (что обычно не рекомендуется) то вам покажется знакомым передача переменных в разметку. с JSX мы можем использовать любые корректные JavaScript-выражений внутри фигурных скобок.

### Подслайд 4 к слайду 3 JSX это тоже выражение

Скорей всего вы уже знакомы с JS методом объекта document, createElement(), и использовали его как в функциях так и циклах. JSX подобен ему.

После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.

Из этого следует, что JSX можно использовать внутри выражений if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.

### Подслайд 5 к слайду 3 Функциональные и классовые компоненты

Компонент может быть объявлен как через класс так и функцию:

Эти 2 компонента эквиваленты друг другу.

### Подслайд 6 к слайду 3 Композиция компонентов

Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения. Неважно, пишем ли мы кнопку, форму или целый экран: все они, как правило, представляют собой компоненты в React-приложениях.

Например, компонент App может отрендерить компонент Welcome несколько раз:

***

### Слайд 4 "Компонент с состоянием"

Помимо входных данных (доступных через this.props), компонент поддерживает внутренние данные состояния (доступные через this.state). Когда данные состояния компонента изменятся, React ещё раз вызовет render() и обновит отрендеренную разметку. Благодаря чему мы может перерисовывать только компонент в котором произошли изменения, не перерисовывая всю страницу.

Обратите внимание что в отличие от обычного JS, в React изменения объекта state производят через метод setState() а не на прямую обращением к к ключу объекта;

### Подслайд 1 к слайду 4 "Классы и хуки"

Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.

Вдобавок к усложнению организации кода и его повторного использования, классы создают существенный барьер в изучении React. Нужно понимать, как работает this в JavaScript, поведение которого отличается от большинства языков. Приходится помнить про привязку контекста для обработчиков событий. Без использования нестабильных синтаксических предложений, код становится многословным. Люди могут прекрасно понимать пропсы, состояние и однонаправленный поток данных, но всё равно путаться с классами. Различия между функциональными и классовыми компонентами в React и тем, когда их использовать, приводят к разногласиям даже между опытными React-разработчиками.

Чтобы решить эти проблемы, хуки позволяют использовать больше возможностей React без написания классов. Концептуально, React-компоненты всегда были ближе к функциям. Хуки обеспечивают доступ к функционалу, но не обесценивают опыт использования React. Хуки предоставляют императивные лазейки и не требуют от вас изучения сложных функциональных или реактивных подходов.

***

### Слайд 5 Методы жизненного цикла.

Мы можем переписать ранее созданные часы используя state и методы жизненного цикла.

В приложениях с множеством компонентов очень важно освобождать используемые системные ресурсы когда компоненты удаляются.

Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting).

Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting).

Метод componentDidMount() запускается после того, как компонент отрендерился в DOM — здесь мы и установим таймер.

Метод componentWillUnmount() запускается при «размонтировании» элемента, в нем мы удаляем таймер.

### Подслайд 1 к слайду 5 Однонаправленный поток данных

В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. Также не важно, как был создан определённый компонент — с помощью функции или класса.

Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов.

Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения.
