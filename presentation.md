# Phaser 3 в наше время

## Коротко о Phaser 3

  Phaser3 единственный известный мне игровой движок. Использует он JS и существует с февраля 2018 года (до этого еще была версия 2, (она так то и до сих пор есть и даже параллельно развивается комюнити)). У него богатая документация. И живое сообщество (я пару раз заходил на офф форум где оперативно получал помощь, слышал так же о дискорд канале).  

  ([положу тут ссылку на офф документацию](https://photonstorm.github.io/phaser3-docs/index.html))


###  Phaser Hint

  Немало важно что Phaser полностью описан в JSDoc, Благодаря чему вы будете получать "подсказки" при вводе ".", знать что делает тот или иной метод, и какие аргументы ему необходимо "скормить". Иии вы можете это недооценивать, но это крайне полезно, т.к. у Phaser огромное количество классов с множеством методов и свойств (я насчитал 226 классов...).

([положу тут ссылку на примеры кода](https://phaser.io/examples))

Но и это не все, у Phaser есть множество учебных материалов и примеров кода, (иногда я тратил по пол дня просто копаясь в примерах, серьезно, и не просмотрел их всех до сих пор, черт побери, там 1803 примера).

Да, большинство примеров используют старый синтаксис, но с другой стороны это позволяет потренироваться в переписывание ES5 на ES6.

Существует несколько "готовых" шаблонов для работы с  Phaser. Одной из них я и воспользовался, в ней используется Вэбпак для сборки проекта + Type Script. Много материала можно почерпнуть в [github Richard Davey](https://github.com/photonstorm?tab=repositories), те же шаблоны.

## Собственно о ES6 в Phaser

(сделать слайды сравнения синтаксисов)

### Модули

Благодаря ES6 модулям код становиться более структурированным и простым для восприятия (к примеру небольшая игра в 183 строк легко разбивается на несколько модулей с заметно меньшим обЪемом кода на 1 модуль).

### Классы

В офф материалах советуют при создании игровых объектов наследоваться от классов Phaser, расширяя их функционал. К примеру можно создать класс Кнопки, наследуемый от картинки/текста, И добавляющими поведение при наведении мыши, и клике. Я это редко применял, и обычно просто добавлял свойства в экземпляр класса Phaser, это проще, но при этом я лишался подсказок в VSC на свои методы/свойства, + еще вел войны с Type Script (в общем не делайте так).

### Остальное

Ну и в целом те же forEach циклы, стрелочные функции, операторы спред/рест, деструктуризация, уменьшают объем кода, добавлять по вкусы.

## Type Script и Phaser

(сделать слайды демонстрирующие обычный JS и TS. Примеры подсказок, мб вместо слайдов запилить кодинг).

В основном когда я слышал про использование Type Script основным преимуществом ставят строгую типизацию, мол это позволяет избежать большого количества проблем/ошибок/багов. Я с этим не сталкивался, (думаю в основном из за использования строгого сравнения ===), но в принципе могу представить такую ситуацию.

Главным для меня стало то что описывая типы вы помогаете себе. VSC подхватывает описание типов и выводит подсказки, и теперь вам не надо держать 10 открытых вкладок, и/или скакать от одного модуля к другому (что бы посмотреть как же точно назывался тот метод...), а достаточно нажать "." и выбрать необходимый метод в сплывшем меню. Ну и помимо этого подсказки аргументов функций + их тип. Благодаря этому вы не только быстрее пишете код по своим модулям, но и так же быстро понимаете что требует тот или иной метод/класс в чужом.

Хочется так же отметить что не стоит бояться Type Script думать то что его сложно освоить, много учить и т.п. Нет, все довольно просто, в конце концов Type Script существует только на стадии разработки, финальный код представляет собой обычный JS. Глобально ничего нового нет. Просто теперь после аргумента функции надо указать его тип (аргумента), или дополнительно описать типы свойств класса. В какой то момент может показаться что это замедляет процесс, и проще просто указать any (т.е. любой), но этим вы лишите себя всех преимуществ использования Type Script. Так же необязательно выводить все типы вручную, VSC может это сделать за вас, исходя из использования переменной. Правда это срабатывает не всегда и не всегда корректно, но тем не менее очень приятная опция.
